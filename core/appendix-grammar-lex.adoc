[appendix]
[[grammar-lex]]
== Regular Lexical Grammar

----
# A Regular Lexical Grammar for GTA3script (informative)
sep := sep ;
eol := eol ;
token := token_char {token_char}
       | '-' (digit | '.') {token_char} ;
string_literal := string_literal ;
plus := '+' ;
minus := '-' ;
star := '*' ;
slash := '/' ;
plus_at := '+@' ;
minus_at := '-@' ;
equal := '=' ;
equal_hash := '=#' ;
plus_equal := '+=' ;
minus_equal := '-=' ;
star_equal := '*=' ;
slash_equal := '/=' ;
plus_equal_at := '+=@' ;
minus_equal_at := '-=@' ;
minus_minus := '--' ;
plus_plus := '++' ;
----

There are only operators, separators, unclassified tokens, and string literals.

Each unclassified token requires parsing context in order to be classified.

Comments are excluded from this grammar because nested block comments are context-free.

This regular grammar is not capable of handling the complete set of words generated by `filename`. For instance, `file-name.sc` would not be interpreted properly. A translator should be careful to handle this case properly.

The following are examples of context dependency for token classification:

----
// for the sake of simplicity separation tokens are omitted.

WORD: WORD:    // label(WORD:) command(WORD:)

WORD WORD      // command(WORD) identifier(WORD)

1234 1234      // command(1234) integer(1234)

X = Y          // identifier(X) '=' identifier(Y)
X Y            // command(X) identifier(Y)

X --           // identifier(X) '--'
X -1           // command(X) integer(-1)

LAUNCH_MISSION a.sc // command(LAUNCH_MISSION) filename(a.sc)
OTHER_COMMAND a.sc  // command(OTHER_COMMAND) identifier(a.sc)
// NOTE: filename is not an identifier because, for instance,
// filename(4x4.sc) cannot be classified as an identifier.

OR             // command(OR)
NOT            // command(NOT)
IF SOMETHING   //
OR OR          // 'OR' command(OR)
OR NOT NOT     // 'OR' 'NOT' command(NOT)
    NOP        //
ENDIF          //

// NOTE: that is a defect actually, see following example:
IF SOMETHING
    AND var    // 'AND' command(var) -- not what we want
    // same problem for OR.
    // NOT is affected by IF NOT var.
ENDIF
----

